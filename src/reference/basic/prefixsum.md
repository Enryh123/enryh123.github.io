---
title: 前缀合与差分
---

## 算法思想
从已知的初始条件出发，依据递推关系，推出所求的结果。

**递推题目需要满足的条件：**
- 从已知条件到所求问题之间，总存在相互的联系。**（递推关系）**
- 递推要确定2点：
	1. 确定初始条件
	2. 确定递推关系（找规律）

**顺推和逆推：**
- 顺推：从事件的开始状态推导到结束状态。[**4451 运输椰子**](https://oj.aicoders.cn/problem/4451)
- 逆推：从事件的结束状态推导到开始状态。[**3677 猴子吃桃**](https://oj.aicoders.cn/problem/3677)
::: details 运输椰子参考程序
```cpp title="4451 运输椰子"
#include<bits/stdc++.h>
using namespace std;

int a[1100];
int main(){
    a[0] = 64062; // 初始值
	for(int i=1; i<=5; i++){ // 顺推
        a[i] = a[i-1]/2 - 1; // 递推式
    }
    cout<<a[5];
	return 0;
}
```
:::

::: details 猴子吃桃参考程序
```cpp title="3677 猴子吃桃"
#include <iostream>
using namespace std;
int a[30];
int main() {
	int n;
	cin>>n;
	a[n] = 1; // 初始值
	for(int i=n-1; i>=1; i--){ // 逆推
		a[i] = (a[i+1]+1)*2; // 递推式
	}
	cout<<a[1];
	return 0;
}
```
:::

## 前缀和

前缀和就像一种累加记录，表示前 `n` 项的和。假设我们有一个数字列表，比如 `[3, 5, 2, 6, 8]`，前缀和就是每次把这些数从头到尾依次累加的结果。

举个例子：
- 第1个前缀和就是第1个数：$3$
- 第2个前缀和就是前两个数的和：$3 + 5 = 8$
- 第3个前缀和是前三个数的和：$3 + 5 + 2 = 10$
- 依此类推，得到一系列累加结果，这些就是前缀和。

我们把这些前缀和放到一个新数组里，就得到一个**前缀和数组**。

### 前缀和数组

前缀和数组就是把所有的前缀和按顺序放在一个数组里。这样当我们想快速知道从第1个数到某个数的累加结果时，就可以直接去前缀和数组里找，非常方便。

用刚才的例子 `[3, 5, 2, 6, 8]`：

- 它的前缀和数组是 [3, 8, 10, 16, 24]。

也就是说：
- 前缀和数组的第1个元素 3 表示第1个数本身；
- 前缀和数组的第2个元素 8 表示前两个数的和 3 + 5；
- 前缀和数组的第3个元素 10 表示前三个数的和 3 + 5 + 2；
- 依此类推。

### 前缀和的递推式子

前缀和数组可以用一个递推公式来计算。假设我们用 `pre[i]` 表示前缀和数组的第 `i` 个元素， `a[i]` 表示原数组中的第 `i` 个元素，那么公式是：

$$\text{prefix[i] = prefix[i - 1] + a[i]}$$


意思是，第 i 个前缀和等于前一个前缀和加上原数组的第 i 个元素。

前缀和的优势和用途

	•	快速求累加和：有了前缀和数组，我们可以快速找到某个位置之前的所有数的和。
	•	求任意区间的和：如果我们想求数组的某一部分的和，有了前缀和数组，我们就不需要重复计算。只需要两步就能算出答案！

如何利用前缀和求区间和？

假设我们有一个数组 arr，前缀和数组是 prefix，如果想快速计算 arr 中从第 L 到第 R 个数的和，可以用以下公式：

￼

这样就能快速求出任何区间的和，而不需要从头开始一个一个加。

例子

假设数组是 [3, 5, 2, 6, 8]，前缀和数组是 [3, 8, 10, 16, 24]。

如果我们想求从第2个数到第4个数的和，也就是 [5, 2, 6] 的和，可以这样做：

	•	用公式 prefix[4] - prefix[1]，即 16 - 3 = 13。
	•	结果 13 就是 [5, 2, 6] 的和。

总结

	•	前缀和：逐步累加得到的和。
	•	前缀和数组：所有前缀和按顺序放在一个新数组里。
	•	递推公式：prefix[i] = prefix[i - 1] + 数组[i]
	•	优点：可以快速求区间和。