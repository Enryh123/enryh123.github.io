## T1分糖果
### 程序的思路：

1. **糖果的除数与余数**：对于一个特定的糖果数量 `k`，小朋友会依次从篮子里拿走糖果，直到剩余的糖果少于 `n`。所以计算糖果能分多少轮的关键在于 `k / n`，而我们奖励的糖果数量则是 `k % n`，即分完糖果后剩下的余数。

2. **关键观察**：
   - 如果 `L` 和 `R` 被相同地整除（即 `L / n == R / n`），那么不论是拿 `L` 还是 `R`，最后奖励的糖果数量将是 `R % n`，因为它代表拿到的糖果数目能均匀分配给小朋友后的剩余部分。
   - 如果 `L` 和 `R` 被 `n` 不同地整除（即 `L / n != R / n`），说明存在某个区间可以增加奖励的糖果数量，这种情况下可以拿到的奖励糖果数量最大是 `n - 1`，这是因为不管怎么分，剩下的最多为 `n - 1`。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, l, r;
    cin >> n >> l >> r;  // 输入小朋友数量 n，最少拿的糖果数量 L，最多拿的糖果数量 R
    
    // 判断 L 和 R 是否会被相同的 n 整除，如果相同则直接取 r % n
    if (l / n == r / n) {
        cout << r % n;  // 如果 L 和 R 在同一轮，则奖励为 r % n，即分完后的剩余糖果
    } else {
        cout << n - 1;  // 否则，可以保证至少剩下 n - 1 块糖作为奖励
    }
    
    return 0;
}
```

### 代码详细解释：

1. **输入**：首先读取三个输入值 `n`（小朋友数量）、`L`（最少拿的糖果数量）、`R`（最多拿的糖果数量）。
   
2. **逻辑判断**：
   - 如果 `L / n == R / n`：即 `L` 和 `R` 被 `n` 相除得到相同的商，这意味着从 `L` 到 `R` 之间不会有多轮糖果分配（不会有多余的一轮），因此我们可以直接使用 `r % n` 来计算最后剩余的糖果数量，这就是我们作为奖励的糖果。
   - 如果 `L / n != R / n`：说明从 `L` 到 `R` 跨过了多个完整的糖果分配轮次，那么我们最多可以得到 `n - 1` 块糖果作为奖励，这是由于在任何一次完整分配中，最多会剩下 `n - 1` 块糖。

3. **输出**：程序最终输出最优情况下你能够得到的最多奖励糖果的数量。


### T2 插入排序
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n, Q;
    cin >> n >> Q;

    // 用 pair<int, int> 存储元素值和它的原始下标
    vector< pair<int, int> > a(n + 1);  // a[i].first 是值, a[i].second 是索引
    for (int i = 1; i <= n; i++) {
        int value;
        cin >> value;
        a[i] = make_pair(value, i);  // 初始化数组，索引从 1 开始
    }

    // 处理每个操作
    while (Q--) {
        int type;
        cin >> type;

        if (type == 1) {
            // 操作类型 1：修改第 x 个元素为 v
            int x, v;
            cin >> x >> v;
            a[x].first = v;  // 更新数组第 x 个元素的值，保持索引不变
        } else if (type == 2) {
            // 操作类型 2：查询第 x 个元素在稳定排序后的数组中的位置
            int x;
            cin >> x;

            // 复制当前数组并进行稳定排序
            vector< pair<int, int> > sorted_a = a;  // 复制数组
            stable_sort(sorted_a.begin() + 1, sorted_a.end());  // 从索引 1 开始进行稳定排序

            // 找到 a[x] 在排序后的数组中的位置 （52分，暴力搜索）
            for (int i = 1; i <= n; i++) {
                if (sorted_a[i].second == x) {
                    cout << i << "\n";  // 输出排序后 a[x] 所处的位置
                    break;
                }
            }
        }
    }

    return 0;
}
```


### T3 网络连接（55分程序）
### 代码注释和解释：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;  // 定义整数 n，表示操作的数量

map<string, int> m;  // 定义一个 map，用来存储IP地址和对应的序号
string o, a;  // 定义两个字符串 o 和 a，分别存类型和IP地址

int main() {
    cin >> n;  // 输入操作的数量
    for (int i = 1; i <= n; i++) {
        cin >> o >> a;  // 输入名称和IP地址
        
        if (o[0] == 'S') {  // 如果操作类型是 'S'，表示服务端
            if (m[a])  // 检查 map 中是否已经存在该IP
                cout << "FAIL\n";  // 如果IP已存在，输出 "FAIL"
            else {
                m[a] = i;  // 如果服务端不存在，进行连接，将IP地址的序号 i 存入 map 中
                cout << "OK\n";  // 输出 "OK" 表示成功
            }
        } else {  // 如果是客户端
            if (!m.count(a))  // 检查 map 中是否存在该IP地址
                cout << "FAIL\n";  // 如果IP不存在，输出 "FAIL"
            else 
                cout << m[a] << '\n';  // 输出IP对应的序号
        }
    }
    return 0;  // 程序结束
}
```

##### `map` 的使用：
- **定义**：`map<string, int> m` 是一个 `map` 容器，其中 `string` 是键（IP地址），`int` 是值（表示序号）。
- **插入元素**：通过 `m[a] = i;` 将IP地址 `a` 与序号 `i` 关联并插入到 `map` 中。
- **查找元素**：
  - `m[a]`：通过键 `a` 获取其对应的值，即该IP地址的序号。
  - `m.count(a)`：判断键 `a` 是否存在于 `map` 中。`count(a)` 返回 0 表示不存在，返回 1 表示存在。

##### `map` 的优势：
- **快速查找**：`map` 底层实现为红黑树，查找、插入和删除操作的时间复杂度为 O(log n)，因此适用于频繁查找和更新的场景。
- **键唯一性**：`map` 自动保证键的唯一性，因此在访问时，如果某个IP地址已存在，直接通过 `map` 检查即可防止重复访问。